
@{
    ViewBag.Title = "Home Page";
}
<br />
<!--wyswietlenie formularza szukajki-->
<div class="container">
    <div class="row">
        <div class="col-md-3">
            <form action="~/Home/Index" method="POST">
                <div class="input-group">
                    <input type="text" id="city" name="city" class="form-control" value="" placeholder="Szukaj">

                    <div class="input-group-btn">
                        <button class="btn btn-danger" type="submit">
                            <i class="glyphicon glyphicon-search"></i>
                        </button>

                    </div>
                </div>
                <input type="radio" id="contactChoice1" name="obiekt" value="Szpitale">
                <label for="contactChoice1">Szpitale</label>
                <input type="radio" id="contactChoice2" name="obiekt" value="Apteki">
                <label for="contactChoice2">Apteki</label>
            </form>
        </div>

    </div>
    <br />
    <div id="map" style="height:400px;width:100%"></div>
    <div id="popup" class="ol-popup">
        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
        <div id="popup-content"></div>
    </div>
</div>
<div id="map" style="width: 600px; height: 400px;"></div>
<!---załadowanie skryptów zewnętrznych Google-->
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDnOtV5TFxLobutxoh5va6vbeN5zT09M94&"></script>

<script>

    let map;
    var tiles;
    let uzytkownik;
    ///sprawdzenie czy przeglądarka obsługuje geolokalizacje - nie czy użytkownik zezwolił
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(showPosition, showError);

    } else {
        alert('Geolocation is not supported in this browser');
    }
    ///funkcja wyświetlająca komunikat gdy użytkownik odmówił użycia lokalizacji
    function showError(error) {
        alert("Wymagane jest udostępnienie lokalizacji do poprawnego działania");

    };

    ///funkcja licząca odległość między pozycją użytkownika a danym punktem (https://stackoverflow.com/questions/18883601/function-to-calculate-distance-between-two-coordinates)
    function calcDistance(end, poczatek, callback) {
        var lat2;
        var lng2;
        var results;

        function deg2rad(deg) {
            return deg * (Math.PI / 180)
        }
        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2, callback) {
            var R = 6371; // Radius of the earth in km
            var dLat = deg2rad(lat2 - lat1);  // deg2rad below
            var dLon = deg2rad(lon2 - lon1);
            var a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2)
                ;
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            results = R * c; // Distance in km
            callback(results);
            return false;
        }///pobranie wspołrzędnych przy wykorzystaniu API Google
        axios.get("https://maps.googleapis.com/maps/api/geocode/json",
            {
                params:
                {
                    address: end,
                    key: 'AIzaSyDnOtV5TFxLobutxoh5va6vbeN5zT09M94'
                }
            })
            .then(function (response) {
                lat2 = response.data.results[0].geometry.location.lat;
                lng2 = response.data.results[0].geometry.location.lng;
                return false;
            })
            .catch(function (error) {
                console.log(error);
            });///async służy do wstrzymywania kodu zawartego w orzekiwaniu na zmianę zmiennych, np. tutaj z undefined; oczekiwanie na dane po prostu
        (async () => {
            while (typeof lat2 === "undefined" && typeof lon1 === "undefined") // define the condition as you like
                await new Promise(resolve => setTimeout(resolve, 1000));
            getDistanceFromLatLonInKm(poczatek.lat, poczatek.lng, lat2, lng2, function (results) {
                callback(results);///callback to alternatywa dla async dla funkcji, jak return tylko dopiero jak będzie zdefiniowana zmienna
            }
            )
        })()
            ;
        return false;
    }

    ///funkcja pobierająca wspołrzędne dla adresu i umieszczająca pinezki na mapie
    function geocode(dane) {

        var location = dane[2];
        var apteka = L.icon({
            iconUrl: 'https://maps.google.com/mapfiles/kml/pal3/icon46.png',

            iconSize: [38, 45], // size of the icon
            popupAnchor: [13, 0] // point from which the popup should open relative to the iconAnchor
        });
        var szpital = L.icon({
            iconUrl: 'https://maps.google.com/mapfiles/kml/shapes/hospitals.png',

            iconSize: [38, 45], // size of the icon
            popupAnchor: [13, 0] // point from which the popup should open relative to the iconAnchor
        });
        var typ = dane[0];
        var opis = dane[1]
        if (opis == "") {
            opis = typ;
        }

        axios.get("https://maps.googleapis.com/maps/api/geocode/json",
            {
                params:
                {
                    address: location,
                    key: 'AIzaSyDnOtV5TFxLobutxoh5va6vbeN5zT09M94'
                }
            })
            .then(function (response) {
                //formatted stuff
                (async () => {
                    while (typeof response.data.results[0] === "undefined") // define the condition as you like
                        await new Promise(resolve => setTimeout(resolve, 1000));

                    destination = { lat: response.data.results[0].geometry.location.lat, lng: response.data.results[0].geometry.location.lng };
                    var url = 'https://www.google.pl/maps/search/' + dane[2];
                    var pinezka;
                    var pinezki = L.layerGroup();
                    if (typ.includes("Apteka")) {
                        pinezka = L.marker([destination.lat, destination.lng]).setIcon(apteka);
                    }
                    else {
                        pinezka = L.marker([destination.lat, destination.lng]).setIcon(szpital);
                    }
                    pinezki.addLayer(pinezka);
                    pinezka.bindPopup("<center>" + opis + '<p><h4><a target="_blank" href="' + url + '">Pokaż drogę</a></h4></center>');
                    pinezki.addTo(map);
                   
                })()
                return false;


            })
            .catch(function (error) {
                console.log(error);
            });
    }

    ///inicjalizacja mapy i pozycji użytkownika
    function showPosition(position)
    {
        map = L.map('map').setView([position.coords.latitude, position.coords.longitude], 15);
        tiles = L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibW90aHVpenlrIiwiYSI6ImNreDRvczdtdzB6MTkybm8xN3UwbHhuazkifQ.fA-YxfkAg4NEqsjsyXX8Jw',
        {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
                'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
            id: 'mapbox/streets-v11',
            tileSize: 512,
            zoomOffset: -1
            }).addTo(map);

        var current_position, current_accuracy;
        
        function onLocationFound(e) {
            // if position defined, then remove the existing position marker and accuracy circle from the map
            if (current_position) {
                map.removeLayer(current_position);
                map.removeLayer(current_accuracy);
            }

            var radius = e.accuracy / 2;

            current_position = L.marker(e.latlng).addTo(map)
                .bindPopup("Jesteś w odległości " + radius + " metrów od tego punktu");

            uzytkownik = current_position;
            current_accuracy = L.circle(e.latlng, radius).addTo(map);
        }

        function onLocationError(e) {
            alert(e.message);
        }
        map.on('locationfound', onLocationFound);
        map.on('locationerror', onLocationError);

        // wrap map.locate in a function
        function locate() {
            map.locate();
        }

        // call locate every 3 seconds... forever ; zapewnia aktualizacje pozycji użytkownika podczas przemieszczania się
        setInterval(locate, 3000);
    }

///pobieranie danych, inicjalizacja mapy, wykonywanie logiki
(async () => {
    while (typeof map === "undefined") // define the condition as you like
        await new Promise(resolve => setTimeout(resolve, 1000));
        ///jeśli użytkownik wystosował konkretne żądanie
        var model = '@Html.Raw(Json.Encode(ViewBag.Obiekty))';
        model = model.split(";_");
        if (model.length > 1) {
            for (i = 0; i < model.length; i++) {
                if (model[i] != '"]' && model[i] != '') {
                    ///umieszczanie pinezek
                    geocode(model[i].split(";"));

                }
            }
        }///jeśli użytkownik jedynie uruchomił aplikację więc pobieramy wszystkie obiekty w promieniu 5 km mające podobny kod pocztowy co on
        else {
            (async () => {
                while (typeof uzytkownik === "undefined") // define the condition as you like
                    await new Promise(resolve => setTimeout(resolve, 1000));

                const latlng = uzytkownik.getLatLng();//pobranie aktualnej pozycji użytkownika
                var zip;
                var miasto;
                var geocoder = new google.maps.Geocoder();//znalezienie kodu pocztowego na podstawie lokalizacji użytkownika ; reverse geocoding
                geocoder.geocode({ 'latLng': latlng }, function (results, status) {
                    if (status !== google.maps.GeocoderStatus.OK) {
                        alert(status);
                    }
                    // This is checking to see if the Geoeode Status is OK before proceeding
                    if (status == google.maps.GeocoderStatus.OK) {
                        miasto = results[0].address_components[3].long_name;
                        zip = results[0].address_components[7].long_name;
                    }
                    var wszystko;
                    ///pobranie wszystkich obiektów mające takie samo miasto i podobny kod pocztowy
                    $.get("/Home/GetAll", { city: miasto, zip: zip }, function (data) {
                        wszystko = data.split(";_");
                    });
                    (async () => {
                        while (typeof wszystko === "undefined") // define the condition as you like
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        for (i = 0; i < wszystko.length; i++) {
                            if (wszystko[i] != '') {
                                const test = wszystko[i];
                                calcDistance(test.split(";")[2], latlng, function (results) {
                                    if (results < 5) {
                                        geocode(test.split(";"));
                                    }
                                })

                            }
                        }
                    })()


                });
            })();
        }
    })();

</script>